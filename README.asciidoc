= yosql image:https://img.shields.io/badge/email-%40metio-brightgreen.svg?style=social&label=mail["Discuss on Google Groups", link="https://groups.google.com/forum/#!forum/metio"] image:https://img.shields.io/badge/irc-%23metio.wtf-brightgreen.svg?style=social&label=IRC["Chat on IRC", link="http://webchat.freenode.net/?channels=metio.wtf"]
Sebastian Hoß <https://seb.xn--ho-hia.de/[@sebhoss]>
:github-org: sebhoss
:project-name: yosql
:toc:
:toc-placement: preamble

image:https://img.shields.io/badge/license-cc%20zero-000000.svg?style=flat-square["CC Zero", link="http://creativecommons.org/publicdomain/zero/1.0/"]
image:https://www.openhub.net/p/{project-name}/widgets/project_thin_badge.gif["Open Hub statistics", link="https://www.openhub.net/p/{project-name}"]

'''

link:https://github.com/krisajenkins/yesql[yesql] inspired build tool that bridges the world of Java & SQL with zero runtime dependencies. It expects a set of .sql files as inputs and generates the required Java code to call the SQL statements define in those .sql files. Besides the generic CLI, support for Maven and Gradle is link:https://github.com/sebhoss/yosql/milestones?direction=asc&sort=due_date&state=open[planned].

'''

== Usage

=== Maven 

1) Add the plugin to your *pom.xml*:

[source, xml]
----
  <build>
    <plugins>
      ...
      <plugin>
        <groupId>com.github.sebhoss.yosql</groupId>
        <artifactId>yosql-maven-plugin</artifactId>
        <version>0.0.1</version>
      </plugin>
      ...
    </plugins>
  </build>
----

2) Add .sql files in *src/main/yosql* and write SQL statements into them.

[source]
----
project/
├── pom.xml
└── src/
    └── main/
        └── yosql/
            └── user/
                ├── findUser.sql
                └── addUser.sql
            └── item/
                ├── queryAllItems.sql
                └── createItemTable.sql
----

3) Execute the *yosql:generate* goal (or just run `mvn generate-sources`) to generate the Java code.

=== Bazel

1) Add git repository to your `WORKSPACE`:

[source]
----
git_repository(
    name = "yosql",
    remote = "https://github.com/sebhoss/yosql.git",
    tag = "0.0.1-bazel",
)
----


2) Write .sql files in a directory of your choice (e.g. `persistence`)

[source]
----
project/
├── WORKSPACE
└── persistence/
    ├── BUILD
    └── user/
        ├── findUser.sql
        └── addUser.sql
    └── item/
        ├── queryAllItems.sql
        └── createItemTable.sql
----

3) Declare a `genrule` in one of your BUILD files:

[source]
----
filegroup(
  name = "your-sql-files",
  srcs = glob(["persistence/**/*.sql"]),
)

genrule(
  name = "yosql-example",
  srcs = [":your-sql-files"],
  outs = [
    "com/example/persistence/UserRepository.java",
    "com/example/persistence/ItemRepository.java",
    "com/example/persistence/util/ResultRow.java",
    "com/example/persistence/util/ResultState.java",
    "com/example/persistence/util/FlowState.java",
    "com/example/persistence/converter/ToResultRowConverter.java",
  ],
  cmd = """
    $(location @yosql//yosql-cli) \
      --inputBaseDirectory persistence \
      --outputBaseDirectory $(@D) \
      --logLevel off
  """,
  tools = ["@yosql//yosql-cli"],
)
----

4) Depend on the generated sources by using `:yosql-example` in the `srcs` of another rule.

=== Standalone (CLI)

1) Download the latest release

2) Write .sql files in a directory of your choice (e.g. `/path/to/your/sql/files`)

3) Call `java -jar yosql-cli.jar --inputBaseDirectory /path/to/your/sql/files --outputBaseDirectory /output/path`

'''

The above configuration is enough to generate two repositories: *UserRepository* and *ItemRepository*. The name is derived from the name of the folder that contains .sql files and can be configured as seen below. Each of them will have regular Java methods to execute the SQL statements defined in those .sql files. The `UserRepository` for example exposes these methods (based on *findUser.sql*):

[source, java]
----
// eagerly loads all results and puts them into the result list
List<ResultRow> findUser(Object userId)

// same as above, but calls 'list.stream()' on the result list
Stream<ResultRow> findUserStreamEager(Object userId)

// lazily loads all rows in a stateful stream (e.g. the Stream needs to be closed after consumption)
Stream<ResultRow> findUserStreamLazy(Object userId)
----

In case your project declares a dependency to RxJava2 (`io.reactivex.rxjava2:rxjava2`), the following additional method will be generated:

[source, java]
----
// lazily loads all rows in a stateful flow which closes automatically
Flowable<ResultRow> findUserFlow(Object userId)
----

You can enable/disable the generation of each of these methods both in the plugin configuration and for each statement individually.

The *addUser.sql* file might contain a writing statement (e.g. `INSERT INTO ...`) which generates the following Java methods in the same `UserRepository`:

[source, java]
----
// writes a single new user
int addUser(Object userId, Object name)

// batches multiple writes of new users
int[] addUserBatch(Object[] userId, Object[] name)
----

The SQL statements in your .sql files are just plain SQL, e.g. `findUser.sql` could look like this

[source, sql]
----
SELECT  *
FROM    users
WHERE   id = :userId
----

and `addUser.sql` like this:

[source, sql]
----
INSERT INTO users (id, name)
VALUES (:userId, :name)
----

In order to customize the generated code, e.g. change the type of the parameters, a YAML frontmatter can be specified for each SQL statement like this:

[source, sql]
----
-- parameters:
--   - name: userId
--     type: int
SELECT  *
FROM    users
WHERE   id = :userId
----

This changes the generated code to this:

[source, java]
----
// uses 'int' instead of 'Object'
List<ResultRow> findUser(int userId)
Stream<ResultRow> findUserStreamEager(int userId)
Stream<ResultRow> findUserStreamLazy(int userId)
Flowable<ResultRow> findUserFlow(int userId)
----

Changing the result type is possible with the help of a converter:

[source, sql]
----
-- parameters:
--   - name: userId
--     type: int
-- resultConverter:
--   converterType: my.own.UserConverter
--   resultType: my.own.User
SELECT  *
FROM    users
WHERE   id = :userId
----

Which in turn changes the generated code into this:

[source, java]
----
// uses 'User' instead of 'ResultRow' & 'int' instead of 'Object'
List<User> findUser(int userId)
Stream<User> findUserStreamEager(int userId)
Stream<User> findUserStreamLazy(int userId)
Flowable<User> findUserFlow(int userId)
----


`my.own.UserConverter` could look like this:

[source, java]
----
package my.own;

import java.sql.ResultSet;
import java.sql.SQLException;

import my.own.User;
import my.own.persistence.util.ResultState;

public class UserConverter {

    public final User asUserType(final ResultState result) throws SQLException {
        final ResultSet resultSet = result.getResultSet();
        final User pojo = new User();
        pojo.setId(resultSet.getInt("id"));
        pojo.setName(resultSet.getString("name"));
        return pojo;
    }

}
----

Vendor specific statements are support as well. Just add a *vendor* key to your frontmatter like this:

[source, sql]
----
-- name: findUsers
-- vendor: Oracle
SELECT  *
FROM    (
    SELECT  ROWNUM rn, data.*
    FROM    (
        SELECT  *
        FROM    users
        WHERE   id = :userId
    ) data
    WHERE   rn <=  :offset + :limit
)
WHERE rn >= :offset
;

-- name: findUsers
-- vendor: PostgreSQL
SELECT  *
FROM    users
WHERE   id = :userId
OFFSET  :offset
FETCH NEXT :limit ROWS ONLY
;

-- name: findUsers
SELECT  *
FROM    users
WHERE   id = :userId
OFFSET  :offset
LIMIT   :limit
;
----

The first two statements specify a vendor which means that those queries will only be executed when running against the specified database. In case you want to specify a fallback-query that is used whenever no other vendor matches, specify another statement with the same name but no vendor.

Take a look in the *yosql-example* module that contains multiple example .sql files and a small application that uses the generated repositories. A complete list of configuration options follows below.

== Configuration Options

The plugin offers several ways to influence how the generated code looks like. Run `yosql-cli help` to view the help and `yosql-cli help --command generate` to view detailed information of the available configuration options of the `generate` command.

== Alternatives

* https://github.com/OpenGamma/ElSql

== License

To the extent possible under law, the author(s) have dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

You should have received a copy of the CC0 Public Domain Dedication along
with this software. If not, see http://creativecommons.org/publicdomain/zero/1.0/.

== Mirrors

* https://github.com/sebhoss/yosql
* https://bitbucket.org/sebhoss/yosql
